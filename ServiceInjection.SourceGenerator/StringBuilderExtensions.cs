using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace ServiceInjection.SourceGenerator
{
    internal static class StringBuilderExtensions
    {
        internal static StringBuilder AppendHeader(this StringBuilder sb)
        {
            sb.AppendLine($"// <auto-generated date=\"{DateTime.Now:s}\">");
            sb.AppendLine("// This code was generated by ServiceInjection.");
            sb.AppendLine("// Changes to this file may cause incorrect behavior");
            sb.AppendLine("// and will be lost if the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            return sb;
        }

        internal static StringBuilder AppendCall(this StringBuilder sb, string indent, INamedTypeSymbol symbol, IEnumerable<Injection> injections)
        {

            var constructors = symbol.Constructors
                .Where(c => !c.IsImplicitlyDeclared)
                .ToList();

            if (constructors.Count == 1)
            {
                var constructor = constructors.First();
                sb.AppendLine($"{indent}: this(");
                sb.Append($"{indent}    ");
                sb.Append(GetParameterList(injections, constructor));
                sb.AppendLine(")");
            }
            else if (constructors.Count > 1)
            {
                sb.AppendLine($"{indent}// TODO: Handle multiple constructors with parameters");
            }

            return sb;
        }

        private static string GetParameterList(IEnumerable<Injection> injections, IMethodSymbol constructor)
        {
            return string.Join(", ", constructor.Parameters.Select(p => $"{p.Name}: {MatchParameterList(p, injections)}"));
        }

        private static string MatchParameterList(IParameterSymbol parameter, IEnumerable<Injection> injections)
        {
            // match by class type
            var matchByType = injections.FirstOrDefault(i => SymbolEqualityComparer.Default.Equals(i.Type, parameter.Type));
            if (matchByType != null)
                return matchByType.Name;

            // match by injected class type
            var matchByInjectedType = injections.FirstOrDefault(i => SymbolEqualityComparer.Default.Equals(i.InjectedType, parameter.Type));
            if (matchByInjectedType != null)
                return matchByInjectedType.Name;

            // match by name
            var matchByName = injections.FirstOrDefault(i => i.Name == parameter.Name);
            if (matchByName != null)
                return matchByName.Name;

            return "default";
        }


        internal static StringBuilder AppendCtor(this StringBuilder sb, string indent, ISymbol symbol, IEnumerable<Injection> injections)
        {
            sb.Append(indent + $"public {symbol.Name}(");
            var skipFirst = true;

            foreach (var injection in injections)
            {
                if (skipFirst)
                {
                    skipFirst = false;
                }
                else
                {
                    sb.Append(", ");
                }

                var typeToUse = injection.InjectedType ?? injection.Type;

                if (injection.Required)
                {
                    sb.Append($"{typeToUse.Name} {injection.Name}");
                }
                else
                {
                    sb.Append($"{typeToUse.Name} {injection.Name} = null");
                }
            }

            sb.AppendLine(")");

            return sb;
        }


        internal static StringBuilder AppendBody(this StringBuilder sb, string indent, IEnumerable<Injection> injections)
        {
            foreach (var injection in injections)
            {
                if (injection.Required)
                {
                    sb.Append($"{indent}this.{injection.Name} = {injection.Name} ?? throw new ArgumentNullException(nameof({injection.Name}));");
                }
                else
                {
                    sb.Append($"{indent}this.{injection.Name} = {injection.Name};");
                }
                sb.AppendLine();
            }

            return sb;
        }

    }
}