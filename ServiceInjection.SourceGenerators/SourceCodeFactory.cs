using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace CodeIX.ServiceInjection.SourceGenerators;

internal class SourceCodeFactory
{
    private readonly IEnumerable<Injection> _injections;
    private readonly INamedTypeSymbol _symbol;

    public SourceCodeFactory(INamedTypeSymbol symbol, IEnumerable<Injection> injections)
    {
        _symbol = symbol ?? throw new ArgumentNullException(nameof(symbol));
        _injections = injections ?? throw new ArgumentNullException(nameof(injections));
    }

    public string GenerateSourceCode()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.Append(GenerateCompilationUnit());
        return sb.ToString();
    }

    private CompilationUnitSyntax GenerateCompilationUnit()
    {
        var compilationUnit = CompilationUnit()
            .WithUsings(CreateUsings())
            .AddMembers(CreateClassAndNamespaceDeclaration());

        return compilationUnit.NormalizeWhitespace();
    }

    private MemberDeclarationSyntax CreateClassAndNamespaceDeclaration()
    {
        var isGlobalNamespace = IsGlobalNamespace(_symbol);

        var classDeclaration = ClassDeclaration(_symbol.Name)
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddMembers(CreateConstructor());

        if (isGlobalNamespace)
            return classDeclaration;

        var namespaceDeclaration = NamespaceDeclaration(ParseName(_symbol.ContainingNamespace.ToDisplayString()))
            .AddMembers(classDeclaration);
        return namespaceDeclaration;
    }


    private ConstructorDeclarationSyntax CreateConstructor()
    {
        var parameters = _injections
            .Select(CreateParameterFromInjection)
            .ToList();

        var constructor = ConstructorDeclaration(_symbol.Name)
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .WithParameterList(ParameterList(SeparatedList(parameters)))
            .WithInitializer(CreateConstructorCall())
            .WithBody(CreateMethodBody());

        return constructor;
    }

    private ParameterSyntax CreateParameterFromInjection(Injection injection)
    {
        var typeToUse = injection.InjectedType ?? injection.Type;
        var typeName = GetFullTypeName(typeToUse);
        var parameterSyntax = Parameter(Identifier(injection.Name)).WithType(ParseTypeName(typeName));

        if (injection.IsOptional)
        {
            parameterSyntax = parameterSyntax.WithDefault(EqualsValueClause(LiteralExpression(SyntaxKind.NullLiteralExpression)));
        }

        return parameterSyntax;
    }

    private ConstructorInitializerSyntax CreateConstructorCall()
    {
        var constructors = _symbol.Constructors.Where(c => !c.IsImplicitlyDeclared).ToList();
        switch (constructors.Count)
        {
            case 0:
                // No constructors, so we won't call one
                return null;
            case 1:
                var constructor = constructors.First();
                var arguments = GetConstructorArguments(constructor);

                // Erstellen eines 'this'-Konstruktoraufrufs mit Argumenten
                return ConstructorInitializer(SyntaxKind.ThisConstructorInitializer,
                    ArgumentList(SeparatedList(arguments)));
            default:
                // TODO: Handle multiple constructors with parameters; right now, we don't know which one to call
                return null;
        }
    }

    private IEnumerable<ArgumentSyntax> GetConstructorArguments(IMethodSymbol constructor)
    {
        return constructor.Parameters
            .Select(parameter => Argument(IdentifierName(MatchParameterList(parameter))));
    }


    private BlockSyntax CreateMethodBody()
    {
        return Block(_injections.Select(CreateAssignmentStatement));
    }

    private StatementSyntax CreateAssignmentStatement(Injection injection)
    {
        var assignmentExpression = CreateAssignmentExpression(injection);

        if (!injection.IsOptional)
        {
            assignmentExpression = AddNullCheck(assignmentExpression, injection.Name);
        }

        return ExpressionStatement(assignmentExpression);
    }

    private ExpressionSyntax CreateAssignmentExpression(Injection injection)
    {
        return AssignmentExpression(
            SyntaxKind.SimpleAssignmentExpression,
            IdentifierName($"this.{injection.Name}"),
            IdentifierName(injection.Name));
    }

    private ExpressionSyntax AddNullCheck(ExpressionSyntax expression, string parameterName)
    {
        return BinaryExpression(
            SyntaxKind.CoalesceExpression,
            expression,
            ThrowExpression(
                ObjectCreationExpression(ParseTypeName(nameof(ArgumentNullException)))
                    .WithArgumentList(
                        ArgumentList(SingletonSeparatedList(
                            Argument(
                                InvocationExpression(
                                    IdentifierName("nameof")).WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName(parameterName))))
                                )
                            )
                        ))
                    )
            )
        );
    }


    private static bool IsGlobalNamespace(ISymbol symbol) => symbol is { ContainingNamespace.IsGlobalNamespace: true };

    private HashSet<string> GetNamespaces()
    {
        var namespaces = new HashSet<string>
        {
            "System"
        };
        foreach (var injection in _injections)
        {
            AddNamespace(namespaces, injection.Type);
            AddNamespace(namespaces, injection.InjectedType);
        }

        return namespaces;
    }

    private static void AddNamespace(ISet<string> namespaces, ISymbol typeSymbol)
    {
        if (typeSymbol == null || IsGlobalNamespace(typeSymbol))
            return;

        var ns = typeSymbol.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(ns))
        {
            namespaces.Add(ns);
        }
    }


    private string MatchParameterList(IParameterSymbol parameter)
    {
        // match by class type
        var matchByType = _injections.FirstOrDefault(i => SymbolEqualityComparer.Default.Equals(i.Type, parameter.Type));
        if (matchByType != null)
            return matchByType.Name;

        // match by injected class type
        var matchByInjectedType = _injections.FirstOrDefault(i => SymbolEqualityComparer.Default.Equals(i.InjectedType, parameter.Type));
        if (matchByInjectedType != null)
            return matchByInjectedType.Name;

        // match by name
        var matchByName = _injections.FirstOrDefault(i => i.Name == parameter.Name);
        if (matchByName != null)
            return matchByName.Name;

        return "default";
    }


    private static string GetFullTypeName(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol { IsGenericType: true } namedTypeSymbol)
            return typeSymbol.Name;

        var genericArguments = namedTypeSymbol.TypeArguments;
        var genericArgumentsString = string.Join(", ", genericArguments.Select(arg => arg.ToDisplayString()));

        return $"{namedTypeSymbol.Name}<{genericArgumentsString}>";
    }

    public SyntaxList<UsingDirectiveSyntax> CreateUsings()
    {
        var namespaces = GetNamespaces();

        namespaces.Remove(_symbol.ContainingNamespace.ToDisplayString());

        var systemUsings = namespaces
            .Where(ns => ns.StartsWith("System"))
            .OrderBy(ns => ns)
            .Select(ns => UsingDirective(ParseName(ns)));

        var otherUsings = namespaces
            .Where(ns => !ns.StartsWith("System"))
            .OrderBy(ns => ns)
            .Select(ns => UsingDirective(ParseName(ns)));

        return List(systemUsings.Concat(otherUsings));
    }
}